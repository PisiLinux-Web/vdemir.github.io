---
layout: post
title:  Derleyicinin[compiler] parçaları[yetenekleri] nelerdir?
date:   2018-01-03 12:52:00
tags:   C Programlama
comments: False
---

{{ page.title }}
================

<p class="meta">4 Ocak 2018 - Türkiye</p>

<p class="ui_qtext_para">Genel amaçlı bir dil için bir derleyicinin birincil bileşenleri şunlardır:</p><ul><li>Simge tablosu - İsim, veri türü, kapsam, bağlantı vb. de dahil olmak üzere tanımlayıcılar hakkında bilgi sağlar.</li><li>Sözcüksel[Lexical] analizci - Giriş kaynak kodunu okumak, girdiyi tek tek belirteçlere ayırabilmek ve (bazı durumlarda) sembol tablosuyla etkileşim kurmaktan sorumludur.

Sözcüksel analizciler genellikle lex veya flex gibi kuralları ve eylemleri genel amaçlı bir programlama dili haline dönüştürmek için kullanılan kurallar ve eylemler şeklinde uygulanmaktadır.</li><li>Ayrıştırıcı[parser] - Sözcüksel analizcinin dilin sözdizimsel kurallarına uydurduğu belirteç dizilerini eşleştirmesinden ve programın dahili bir temsilini (örneğin, soyut sözdizim ağacı vb.) oluşturmaktan sorumludur. Bir ayrıştırıcı, bunu doğrulamaktadır. giriş dili dilin sözdizimi kurallarıyla eşleşir ve (çoğunlukla) girdinin anlamsal anlamda mantıklı gelip gelmediğine bakar. Ayrıştırıcılar genellikle kurallar ve eylemler biçiminde uygulanır, kuralları dönüştürmek için yacc veya bison gibi araçları kullanırlar ve eylemleri genel amaçlı bir programlama diline dönüştürür. Ayrıştırıcı çıktısı, programın yapısını, programın donanımdan bağımsız bir ara dil gösterimini ya da her ikisinin bir kombinasyonunu temsil eden bir veri yapısı olabilir.</li><li>Optimize Edici - Son programdaki talimat sayısını, son programın gerektirdiği bellek miktarını, son programın genel hızını veya bunların bir kombinasyonunu azaltmanın yollarını bulmak için ayrıştırıcı çıktısını inceler. Kod boyutu ve kod hızı arasında genellikle bir zaafiyet vardır ve bu bazen kullanıcı tarafından konfigüre edilebilir. Bir eniyileyici CPU hedefinden bağımsız seviyede (ayrıştırıcı çıktısı, nihai hedef CPU hakkında bilgi sahibi olmadan), CPU'ya özgü komut düzeyinde (hedef mimarinin derin bilgisi gerektirir) veya bazıları ikisinin birleşimi. Bazı uygulamalarda, optimizasyon için birden fazla aşama vardır. Modern iyileştiriciler tarafından gerçekleştirilen analiz, talimatlar ve veriler için önbellek hitlerinin en üst düzeye çıkarılması gibi konularda çok sofistike çalışıyor </li><li>Kod üreteci - Ayrıştırıcı ve iyileştirici tarafından sağlanan bilgileri kullanarak, nihai programın gerçek makine talimatlarını çıkartır. (Bazı durumlarda, iyileştirici ve kod üretecinin özellikleri bir araya getirilir.) Kod üreteci, hedef CPU'nun yönerge seti hakkında yakından bilgi sahibidir ve montaj dili kaynak kodunu (nesne koduna eklenmelidir) üretebilir veya doğrudan bağlantıya hazır nesne kodu üretirler. </li></ul><p class="ui_qtext_para">Birçok komut satırı aracı ve IDE, derleme sonrasında otomatik olarak bağ oluşturabilse de, bağlayıcı[linker] genellikle derleyiciden ayrı bir araç olarak düşünülür.</p>


<p class="ui_qtext_para">Çok kısa: Okuma, Ağaç Dönüşümü ve Yazma. Düzgün okuma, Özet Sözdizimi Ağacı dönüşümleri ve optimizasyonu ve Kod Üretimi.</p><p class="ui_qtext_para">Generally, a compiler (proper) is made up of:</p><ul><li>Kaynak kod akışını okur ve derleyicinin kendisi tarafından kullanılan belirteçlere veya sembollere dönüştüren bir çeşit READER; Genellikle, okuyucu makroları (Common Lisp'de), önişlemci makroları (C'de), lekserler, tokenizerler veya simgesel interning kuralları vb. şeyler içeren çok parçalı bir süreçtir. Bazı dillerde okuma zamanı değerlendirmesi de yapılabilir : Bu aşamada derhal değerlendirilen (yürütülen) kod.</li><li>Some kind of step which then takes the stream of tokens and converts them into an Astract Syntax Tree (AST). In Lisp-type languages, this is a bit of a non-issue (the source code is already in AST form), but in Algol-type languages (like C) this can be rather a bit more work. Things that can come into play here include block structures, operator associativity, and so forth. In Common Lisp, and some other languages, there may a macro-expansion step here, in which parts of the AST are expanded to produce more tree structure. (In an interpreted language, the process often ends here.)</li><li>Once in AST form, the compiler will typically re-arrange the code in various ways; this is the bulk of the compiler’s actual work. This stage might involve transforming into single-assignment form with φ (phi) joins; eg.<br /><br />let x := 4.<br />if [some-condition?] then:<br />&nbsp;set x := 0.<br />else:<br />&nbsp;set x := 42.<br />end if.<br />print x.<br /><br />… might be internally transformed into:<br /><br />x₀ ← 4<br />if [some-condition?] then:<br />&nbsp;x₁ ← 0<br />else:<br />&nbsp;x₂ ← 42<br />end if.<br />x₃ ← φ(x₁, x₂)<br />print x₃.</li><li>If the compiler performs optimization passes, they will usually occur here as well. Removing unreachable code, eliminating unused variables (such as x₀ in the above example), and discovering constants that can be computed in advance (eg: the expression “42 + #.(this-year)” might have been transformed into “42 + 2016” which can be computed at compile-time as “2058”), all may occur here.</li><li>Once the AST has been transformed into the compiler’s best form, it will usually then begin Code Generation, assigning variables to registers on the target processor, and deciding what sequences of machine instructions to write.</li><li>Sometimes, additional optimizations are performed on the generated code, as well.</li><li>Then, the Assembly stage takes the generated code and emits the actual binary machine-language form. In some languages, like C, static library linkages might be emitted here.</li></ul><p class="ui_qtext_para">The exact process is dictated more by the language being compiled, than by the target machine. Languages with strong standards and many competing compilers (C, Java, Common Lisp) tend to have standards which specify very precisely what steps must be taken, whereas new languages with smaller “ecosystems” may rely upon a reference (or only) compiler’s implementation.</p>
