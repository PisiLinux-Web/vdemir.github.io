---
layout: post
title:  Derleyicinin[compiler] parçaları[yetenekleri] nelerdir?
date:   2018-01-03 12:52:00
tags:   C Programlama
comments: False
---

{{ page.title }}
================

<p class="meta">4 Ocak 2018 - Türkiye</p>

<p class="ui_qtext_para">Genel amaçlı bir dil için bir derleyicinin birincil bileşenleri şunlardır:</p><ul><li>Simge tablosu - İsim, veri türü, kapsam, bağlantı vb. de dahil olmak üzere tanımlayıcılar hakkında bilgi sağlar.</li><li>Lexical analyzer - Responsible for reading the input source code, breaking the input to individual tokens, and (in some cases) interacting with the symbol table. Lexical analyzers are often implemented in the form of rules and actions, using tools like lex or flex to convert the rules and actions into a general-purpose programming language.</li><li>Parser - Responsible for matching sequences of tokens provided by the lexical analyzer to syntactic rules of the language, and for creating an internal representation of the program (e.g., and abstract syntax tree, etc.). A parser verifies that the input language matches the syntax rules of the language, and (in many cases) whether the input makes sense semantically. Parsers are often implemented in the form of rules and actions, using tools like yacc or bison to convert the rules and actions into a general-purpose programming language. The output of a parser might be a data structure that represents the structure of the program, a hardware-independent intermediate language representation of the program, or a combination of both.</li><li>Optimizer - Examines the output of the parser to find ways to reduce the number of instructions in the final program, the amount of memory required by the final program, the overall speed of the final program, or some combination of these. There is often a tradeoff between code size and code speed, and this is sometimes configurable by the user. An optimizer might operate at just the CPU-target-independent level (the output of the parser, with no knowledge of the final target CPU), at the CPU-specific instruction level (which requires deep knowledge of the target architecture), or some combination of both. In some implementations, there are multiple phases to optimization. The analysis performed by modern optimizers is often very sophisticated, dealing with issues such as maximizing cache hits for instructions and data, etc.</li><li>Code generator - Outputs the actual machine instructions of the final program, using information provided by the parser and optimizer. (In some cases, aspects of the optimizer and code generator are combined.) The code generator has an intimate knowledge of the target CPU’s instruction set, and may generate assembly language source code (which must then be assembled into object code) or it may directly generate object code that is ready for linking.</li></ul><p class="ui_qtext_para">The linker is typically considered a separate tool from the compiler, although many command-line tools and IDEs can automatically perform linking after compilation.</p>


<p class="ui_qtext_para">In very brief: Reading, Tree Transformation, and Writing. Properly, Reading, Abstract Syntax Tree transformations and optimization, and Code Generation.</p><p class="ui_qtext_para">Generally, a compiler (proper) is made up of:</p><ul><li>Some kind of READER, which reads the source code stream and breaks it down into the tokens or symbols used by the compiler itself; often, this is a multi-part process, involving things like reader macros (in Common Lisp), preprocessor macros (in C), lexers, tokenizers or symbolic interning rules, etc. In some languages, there may also be read-time evaluation: code that is immediately evaluated (executed) during this phase.</li><li>Some kind of step which then takes the stream of tokens and converts them into an Astract Syntax Tree (AST). In Lisp-type languages, this is a bit of a non-issue (the source code is already in AST form), but in Algol-type languages (like C) this can be rather a bit more work. Things that can come into play here include block structures, operator associativity, and so forth. In Common Lisp, and some other languages, there may a macro-expansion step here, in which parts of the AST are expanded to produce more tree structure. (In an interpreted language, the process often ends here.)</li><li>Once in AST form, the compiler will typically re-arrange the code in various ways; this is the bulk of the compiler’s actual work. This stage might involve transforming into single-assignment form with φ (phi) joins; eg.<br /><br />let x := 4.<br />if [some-condition?] then:<br />&nbsp;set x := 0.<br />else:<br />&nbsp;set x := 42.<br />end if.<br />print x.<br /><br />… might be internally transformed into:<br /><br />x₀ ← 4<br />if [some-condition?] then:<br />&nbsp;x₁ ← 0<br />else:<br />&nbsp;x₂ ← 42<br />end if.<br />x₃ ← φ(x₁, x₂)<br />print x₃.</li><li>If the compiler performs optimization passes, they will usually occur here as well. Removing unreachable code, eliminating unused variables (such as x₀ in the above example), and discovering constants that can be computed in advance (eg: the expression “42 + #.(this-year)” might have been transformed into “42 + 2016” which can be computed at compile-time as “2058”), all may occur here.</li><li>Once the AST has been transformed into the compiler’s best form, it will usually then begin Code Generation, assigning variables to registers on the target processor, and deciding what sequences of machine instructions to write.</li><li>Sometimes, additional optimizations are performed on the generated code, as well.</li><li>Then, the Assembly stage takes the generated code and emits the actual binary machine-language form. In some languages, like C, static library linkages might be emitted here.</li></ul><p class="ui_qtext_para">The exact process is dictated more by the language being compiled, than by the target machine. Languages with strong standards and many competing compilers (C, Java, Common Lisp) tend to have standards which specify very precisely what steps must be taken, whereas new languages with smaller “ecosystems” may rely upon a reference (or only) compiler’s implementation.</p>
